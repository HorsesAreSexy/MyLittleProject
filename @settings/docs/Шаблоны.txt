--- - Design
qwerty.class#id +attr=value of this attribute(+another-attr=Here=is?some+value.with#symbols) ?[!]@prop@ >[mod]anima={mod.fadeOut(this.box.time)}>[garb]button,pony{color:red} >someInitFunc>click=clickCallback>{await new Promise(r=>setTimeout(r,2000));alert(this.mlf.message)}>mouseenter={this.element.style.color='red'}
{
	.class
	                 #id
	   +some-attr=and so $ we . can * use here!!!any +++symbols cos its strict > one line on the property^
	   ?'cond'+'ition'•=•='condition'=[+attribute=that will be set if condition is true .and_some_additional_class]
	   +style.color=red
}
[>]custom-element-aka-pie@and_some_value_for_him{params:for styles}
/.will-show-only-if-previus-will-be-deleted
> .wrap
* .stub
	child-item
	second-child-item

--- - Ideas
парсить от \W до \W, но с исключением, ибо ходовые символы не должны задействоваться, а тоесть: $_-/=@, и пробел.
если парсинг новой комманды начинается со скобки, то паттерн будет другим: \(.+?\)(?!\)|\w)
считать табы или двойные пробелы (можно оба) до первого вхождения какого-либо символа, а там уже насрать

разбиение на итемы: /^(\t{0}|(?:  ){0})(?!\t| |\n|$)({[\s\S]+?^\1})?(.+)?/gm
разбиение на комманды (символ,модификаторы,остальное): /\(.+?\)(?= *[.#+?>]|$)|(^[>*] )|([.#+?>]|^)(\[.+?\])?((?:{.+?}(?= *[.#?+>]|$)|[^.#+?>(])+)/g
распарс боди (ключ,параметры,значение): /(?:(.+?)?({.+?})?=)?(.+)/\

пробелы где-либо кроме валуя ломают парс. Валуй тримится только с правой стороны и только если небыло инкапсуляции
код функции записывается внутри фигурных скобок: {...}, однако можно и просто строку написать, тогда функция будет искаться в локальном и глобальном хранилище функций
Элемент добавляется в ДОМ только после выполнения всех команд из цепочки

в привязке к массиву должна быть возможность указать особый параметр и строку, при этом произойдёт реактивная привязка к событию.

привязка к данным по дефолту реактивна на клиентском уровне, тоесть любое локальное изменение массива/свойства объекта ведёт к перестройке, можно изменить модом

при привязке можно написать запрос к базе, ответ от которой создаст реактивность, при дополнительном моде устанавливается туннель для отслеживания изменений в базе для ультимативной реактивности. Пока мы ожидаем первоначального ответа от сервера можно вставлять дефолтное сообщение о загрузке с возможностью кастомизации через валуй комманды, например. Отсутствие объектов в привязанном массиве всё также хэндлится стабом.

все элементы и их параметры заносятся в отдельный объект, который становится неявной переменной внутри любой функции в темплате (или частью this объекта). У каждого элемента должна быть функция создания (или ресоздания, если он уже создан) и удаления, которые можно триггерить в определённых условиях

соответственно нужен символ как у стаба для "отложенных" элементов, которые заносятся в структурный объект, но не создаются в реале

анимации теперь можно полноценно сделать отдельной командой и возможно даже не менять синтаксис

кастомные ивенты типа "элемент создан", "элемент удалён", "смена роутинга" и т.п.

все функции внутри комманд и сами команды при необходимости должны быть асинхронны и выполняться последовательно, ожидая завершения предыдущей

--- - Todo
Было бы обалденно контролировать итерации и сделать возможность приостановить проход по командам до возникновения определённого события или заного пройтись по всем командам
ни или хотяб сделать отдельную функцию рендеринга и иметь возможность коллить её с отсрочкой

всёже ивенты и моды/гарбы стоит разделить, ибо на ивенты там огромная нагрузка легла по новому концепту.

в синтаксис геттеров свойств из привязанного к элементу объекта (собачки) добавить особый хендлинг рефов. Здесь должна указываться таблица и сам реф, а данные будут браться и отслеживаться из ЕОРО.
Да и у обычных собачек данные должны браться из ЕОРО.
Возможность просто взять и вырубить всю реактивность.
Перед релизом весь дефолтный цсс и жс зауглифаить или сделать в одну строчку.
Роуты с разными гетами должны триггерить перестройку страницы.
Более заметную анимацию смены страницы, например, чтобы полоски были по всему периметру.
Мод для ^, чтобы брался сиблинг, а не парент.
Убедиться, что лэйзи лоад не убирает надпись вплоть до появления страницы.
Мастерская должна быть отдельным пунктом меню, там же будут размещаться запросы на улучшение механики сайта и создании новых фандомов, тобишь это общий раздел по большей части.
Также нужен форум или "сообщество", где можно писать от своего лица для обыкновенного общения и обсуждения происходящего на сайте.
Также нужна ссылка на патреон. Хотя хуй знает зачем именно он, можно и свою систему сделать с донатами и поощрениями, а можно и оба варианта.
Также должен быть магаз, где чуваки могут тратить свои коины за донат или экспу, получая доступ к механикам или ещё какую хуфню.
Если поле является массивом ссылок, то нужно делать фильтр, а не рефер на каждый элемент массива. Проверить это.
Лэйзи лоад форсит появление wait for it при каждой загрузке страницы. Это как вообще?


--- - Docs
- Realised
Первым делом записывается тэг, или не записывается, но тогда он будет дивом по дефолту.
Нестандартные тэги являются пирожками и триггерят загрузку стороннего шаблона и стиля. Передать некое значение в пай можно через @, которое затем появится как this.var в шаблоне. Наследование через "-". Параметры для стилей также передаются фигурными скобками.
Дабы иметь возможность писать контрольные символы внутри ключа или значения без литерации можно всю команду обрамить круглыми скобками.
Все команды для элемента можно записывать построчно внутри фигурных скобок, строго одна строка для одной команды и никаких конфликтов. Наследование это сбрасывает, дочкам скобки нужно открывать вновь.
Параметры передаются как обыкновенный объект с той лишь разницой, что необязательно писать строчные литералы: тип передаваемого значения будет определяться автоматом, однако если значение гарантированно должно быть строкой, то его можно обрамить литералами. Чтобы написать литерал внутри литерала, ставьте впереди • На данный момент поддерживаются только строки, массивы и объекты.
Пробелы возможны ТОЛЬКО перед контрольными символами, для их визуального разделения.
Символ • (Alt+7) является литератором и превращает любой системный символ в обычный (может литерировать самого себя).
.'' - Добавляет класс.
>'' - Добавляет текст.
+[=.]''='' - Присваивает значение свойству элемента. В ключе можно использовать точки, чтобы пройти по цепочке свойств. По дефолту значение устанавливается как аттрибут к элементу, но если в ключе есть точки или выставлен мод ".", то будет установлено свойство. Если значения нет, то свойству просто присваивается true. Если выставлен мод "=", то указанное значение дописывается к тому, что уже есть в свойстве.
#[<>]'' - Превращает элемент в слот для саб страницы. Если указан мод, то будет вестись работа со слотами в паях. Мод < делает элемент слотом внутри пая с определённым именем, а мод > ссылается на этот слот и применяет все комманды к нему.
?[|]*=* - Выполняет некое действие при выполнении условия. Если есть палка в модах, то при невыполнении условия дропаются все команды после этой.
<[~]''|{}={} - Привязка элемента к объекту и его свойствам. Указать можно функцию (асинхронна), которая должна вернуть объект/массив для привязки или названия свойства из core, который должен содержать то же самое. Если указан кей и функция, то результат функции будет затем записан в кору. При изменении свойств объекта, что были задействованы в ключах/параметрах/значениях последующих команд конструкцией @property@ (после первой собачки можно подставить контрольный символ: знак ^ означает взятие данных из core объекта шаблона независимо от наследования; знак | означает отключение реактивности; знак / позволяет вернуть результат работы некого подключённого к этому элементу модуля, для этого внутри записывается название модуля, ставится знак /, а затем производятся действия, пример: @/so.me-m%dule/.activate().gotString@), элемент будет полностью перестраиваться. При привязке к массиву элемент размножится под колличество объектов в нём. Чтобы реактивности и перестраивания не происходило, используйте мод ~. При работе с реактивными массивами использовать строго только методы add, delete и swap (splice,shift,unshift и б-г знает что ещё полностью ломают всю реактивную систему), при использовании оператора delete элемент перестраивается без данных, но остаётся на своём месте, при этом в самом реактивном массиве остаётся пустое место на удалённой позиции.
![^1*?]''{}={}'' - Добавляет ивент и хэндлер к нему (пишется инлайново или ссылаясь на this.core). This ссылается на структуру. Функция асинхронна, принимает (или уже содержит в инлайновом стиле) две переменные - event (объект зафайренного события) и stopEvent (функция, удаляющая данный обработчик события). Функция для остановки данного оработчика (стопер) заносится в структуру в объект events под именем события, значением в котором является массив с прочими стоперами для того же ивента. Чтобы остановить все обработчики определённого события или событий используйте функцию .stopEvent('event_name',...) из структуры элемента. Моды ^, 1, * - просто опции capture, once и passive соответственно, которые также можно установить в опциях. Мод ? позволяет работать с тумблерами, которым требуются ивент(ы) для фаира и коллбэки для исполнения. Если в ключе указать ивент, а в валуе название тумблера, то оный начнёт переключаться при срабатывании ивента и активировать коллбэки. Если ключом указать название тумблера, а валуём функцию, то на тумблер навесится коллбэк. Функция содержит в себе при этом всё то же самое, а также переменную tumb со значением true или false связанного с ней переключателя.
/!\DEPRECATED/!\ !drag{}={} - Кастомный ивент, позволяет таскать элемент по экрану и файрится, когда элемент отпускаешь. В функцию, 3им (неявно top) и 4ым (неявно left) параметрами добавляются строковые значения соответствующих свойств. Таскается элемент при помощи свойств top и left, такчто он обязан быть не статичным. По дефолту мы будем таскать элемент, который зажали, чтобы это изменить указываем параметр up равным количеству родителей, по которым нужно подняться до нужного элемента. При перетаскивании элемент будет позиционироваться от края экрана, чтобы позиционировать его от некого родителя, указываем параметр for равным количеству подъёмов по родительской ветке.
![1?]swap|delete|update{}={} - Ивенты мутаций, файрятся только когда меняется связанный с элементом реактивный объект. Из опций доступна только once. Удалить можно также через метод .stopEvent() на элементе. Асинхронный коллбэк срабатывает ПОСЛЕ того как с произошли изменения в связанном массиве/объекте и ДО того как что-либо произошло с самим DOM элементом, который изменится уже после резольва асинхронного коллбэка. Как обычно контекст коллбэка (this) ссылается на структуру элемента. Swap происходит когда объект меняет свою позицию внутри реактивного массива, при этом первый параметр (который event object по традиции) содержит в себе свойства: name - название ивента, target - элемент с которым происходит свап. При этом если это взаимный обмен позициями, а не односторонний, то ивенты сработают отдельно на обоих элементах. Delete происходит при удалении объекта из массива, а также и элемента с ним связанного, event объект содержит только name. Update полностью отменяет дефолтную перестройку элемента при изменении связанного реактивного объекта (а также разрывает связь с core, если она была создана конструкцией @^property@), вместо этого запускает указанный коллбэк, создавая ручную реактивность, event объект содержит name а также: was - копия объекта к которому был привязан doer до изменений, now - актуальный объект с котрым связан данный элемент. Удаление всех update ивентов возвращает дефолтную перестройку. Update ивент будет срабатывать даже на элементах, у которых небыло интерполяции свойств с изменённого связанного объекта.
*[>]''{} - Загружает и применяет стили из указанного пая (роутинг через "/").
&[>]''{}={} - Загружает и применяет указанный модуль и опционально коллбэк после его фаира. Параметры вносятся как неявные переменные внутрь модуля, если он объявлен функцией или просто прокидываются ввиде объекта вторым параметром в конструкторе, коли модуль - класс (подробнее об этом в API). Также внутри функции все параметры доступны внутри объекта "arguments". Сам результат работы мода записывается в структуру элемента под своим именем в объект mods.
~[>]{}|''{} - Выполняет функцию (асинхронную). Можно брать заготовленную из коры и передавать аргумент ввиде объекта. В обоих случаях контекст ссылается на структурный объект. Мод > позволяет не блокировать поток на время выполнения.
| - Означает начало создания нового элемента, который единолично окажется внутри текущего, тобишь все последующие команды применяются уже к новому элементу.
%[|#!]''{} - Установка картинки в элемент с добавлением необходимых стилей или просто выдача src для img тэга. На время загрузки в элемент вносится радужная заглушка. Можно указать size, repeat, position css свойства в объекте для изменения отображения картинки, background- к ним спереди автоматом приставится. Мод ! будет инициировать загрузку картинки только когда четверть от элемента появится в окне браузера. Мод | блокирует поток, пока картинка не будет загружена (сколько ей нужно время, чтобы она отрисовалась невозможно отследить), игнорируется в паре с предыдущим модом естественно. Мод # убирает радужную заглушку. Для смены картинки у структуры элемента появляется функция image, где первый параметр - путь до картини, а второй, необязательный, убирает градиент при смене, если он трушен.
^'' - Все последующие действия после этого символа будут происходить с указанным родителем. Указать можно как цифру (на сколько ступеней вверх нужно подняться по древу родителей), так и селектор. Если символ стоит вначале строки, то никакого элемента вовсе создаваться не будет.
/ - Игнорирует строку/блок, если символ стоит в самом начале.

- Feature
Нестандартный или тирчатый тэг триггерит загрузку пая.
>[+]''='' - Добавить возможность сразуже добавить текста для новосозданного элемента в валуе.
&[mod|garb]''{}=fn - Выполняет функцию (в ней должны быть некие неявные переменные с инфой о элементе) или ищет функцию в хранилище коллбэков, если в валуе строка. Если есть кей, то функция выполнится только при триггере этого ивента. Если переданы моды, то кей определяет название применяемого к элементу мода/гарба, можно передать параметры для загрузки, а в валуе можно указать функцию, которая заколлится после загрузки мода/гарба, в ней будет экземпляр класса модуля под названием "mod", коли загружался модуль.
?[%+-]''=fn|bool - Приостанавливает выполнение цепочки команд, если не выполнится условие. При [%] элемент добавится в ДОМ даже если цепочка была приостановлена, но будет скрыт, пока она не выполнится полностью. При [+] цепочка будет приостановлена в любом случае, а в кей указывается ивент, при котором цепочка продолжится, в валуе можно дополнительно указать коллбэк, который сработает вместе с этим ивентом. При [-] в кей устанавливается ивент, при котором цепочка команд будет выполнена заного и элемент, соответственно, пересоздастся, а также коллбэк, который до этого выполнится.
Надо бы переходить на Map и WeakMap вместо обычных объектов.
в модуле форм, для сохранения введённых данных, нужно юзать sessionStorage, а для запоминания вариантов заполнения для всей формы или отдельных полей - localStorage
capture и bubble в ивентах - олуненная тема, мб я могу что-то у себя улучшить благодаря этому?
мб как-то редиректы реализовать?
добавить в базу геттер every или all, чтобы была возможность не указывать функцию выборки
если в treat будет выполнение комманд, после которых дата будет возвращаться ввиде массива, то у меня будут проблемы
Для ивентов: - удаляет все хэндлеры указанного типа либо один конкретный, если также было указано название свойства объекта box где хранится функция-хэндлер с теми опциями, что были при установке (ничерта не поделать, таковы законы ЖСа). | перезаписывает собой все прочие ивенты того же типа.
Для достижения того, что выше, нужен объект в дате, который будет в себе хранить массивы с хэндлерами на каждый тип и их параметры (можно на сам хэндлер зааттачить)
ивент now который тутже выполнит указаный коллбэк (вместо .fn, который был раньше)

- Bugs
+При возвращении через хистори паи не работают
+При скачках с многоуровневого саба на вкорне другой саб, всё отрабатывает верно, но в адресной строке неверный путь
+Если быстро переходить по страницам, то анимации багаются и новые страницы исчезают. Нужны стопперы анимок.