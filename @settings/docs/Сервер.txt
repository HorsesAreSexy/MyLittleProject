Пример: db.users.reverse().filter({ageSearch},(age,music)=>age==ageSearch&&music.includes(this[0]),db.music.find((name)=>name.match(musicSearch)).get('id')).limit(10).get('id','name')

db - стартовое прокси для генерации запроса на сервер. Использовать можно только геттеры. Запрос выполнится только после вызова методов-окончаний, после чего вернётся промис для ожидания ответа, а до этого незаконченную цепочку можно сохранить где угодно и реиспользовать.

['table_name'] - название таблицы, на которые разбита вся база. Этот геттер обязательно должен идти первым.
['function_name'](...*) - инвок кастомной функции, которая хранится в @settings/dbFuncts.js
Контекст такой функции содержит в себе:
base - инстанс базы, с которой была выполнена функция
project - имя проекта, с которого вызвана функция
user - объект с данными о юзере, который вызвал функцию, в user.data находятся его личные поля из юзер таблицы (определяются моделью и меткой need) коли он авторизован
bury - сеттер, который добавляет указанную функцию к массиву user.burry (или создаёт оный). Все функции в данном массиве выполнятся при отключении юзера от сервера (обрыв соединения/выход с сайта).

.return('id'|'bool'|'numb'|'len'|false) - Скользящий метод, определяет в какой форме будет возвращён индикатор выполнения запроса. Бесполезно, если .get() финальный метод. По дефолту это булки. "len" доступен только в случаях, когда возвращается массив значений, вместо этого будет получено количество элементов в нём. Если запрос вернул ошибку из гард функции (см. модель), то независимо ни от чего будет возвращён текст этой ошибки (только в этом случае можно получить строку в качестве ответа), за исключением "len", который будет продолжать просто подсчитывать.
.refer(...''|[]) - Выборка объекта по конкретному id. Будет зааффекчен один объект. Можно указать множество айдишников или массив, тогда и возвращён будет массив. Этот метод выборки быстрее любых других.
.filter(fn) - Прогоняет все записи в таблице через /1/ функцию (НЕ асинхронна). Коли функции нет, будет браться всё подряд.
.find(same) - То же самое, но фильтрация прерывается при нахождении первой подходящей записи. В итоге сервер зааффектит один объект.
.push(...{}|[]) - Финальный метод, тоесть после него больше ничего использовать нельзя и он возвращает промис. Заносит переданные объекты в таблицу. Если был передан один объект, то будет возвращено просто результирующее значение, если было передано множество объектов или же массив с объектами, то всегда будет возвращаться массив из результатов.

.limit(123[,123]) - Опциональный метод, позволяющий вернуть с сервера только определённое количество записей, указанное в /1/. По дефолту равен 100. /2/ определяет сколько записей с начала нужно пропустить в итоговой выдаче, можно указать отрицательное значение, тогда это будет говорить о том, сколько нужно взять записей с конца.
.sort(...''|...fn) - Если /1/ - строка, то указывает по какому полю нужно сортировать полученные результаты, а если функция, то сортировка будет происходить по результату работы этой функции (в параметрах, также как и в фильтре/файнде, указываются необходимые для работы поля). Поля с кроссзапросами будут предоставляться ввиде строки с айди(шниками), иначе бы сервер ебанулся такое количество кроссзапросов хуячить! Если в результате сравнения два значения оказались равны, то будет продолжаться сравнения по цепочке аргументов. По дефолту сортирует по id.
.reverse() - Производит выборку от меньшего к большему. Без данного метода в цепочке выборка происходит дефолтно от большего к меньшему.

.get([...''|{}]) - Финальный метод. Запрашивает все выбранные данные. Если ничего не передано, объекты будут содержать в себе все свойства, иначе объекты будут содержать в себе только указаные в /1/ свойства. Если ничего не найдено вернётся null. Если передаётся объект, то он должен содержать в себе имя поля как ключ и функцию как значение. Эта функция принимает единственный аргумент ввиде взятого из записи значения и трансформирует его, передавая клиенту результат её выполнения (полезно, когда нужно показать лишь кусочек текста или лишь подсчитать длину символов). Однако если функция указывается для кросс-табличного поля, то необходимо указывать поля, которые в итоге будут использоваться в этой функции. Если вместо функции указан объект, то поле распадётся на перечисленные в ключах поля, а в переданные значением функции будет также передаваться значение исходного поля (полезно, когда из одного поля нужно создать несколько других).
.react(same) - Идентично, однако выбранные таким образом данные будут автоматически пополняться при поступлении подходящих в базу.
.necro(same) - То же самое, что и get, но выборка производится по удалённым записям.
.set({}) - Финальный метод. Перезаписывает свойства во всех выбранных объектах переданным в /1/ объектом. /1/ содержит в себе пару: ключ как название поля и значение ввиде строки или функции, которая принимает в себя старое значение поля и внесётся в итоге то, что вернёт эта функция. В функцию передаётся один аргумент ввиде значения поля, кроссзапросы не выполняются. Если реферы уже на руках, то просто перечисляем их в массиве или записываем строкой, разделяя запятой, а если нужно внести какие-то новые данные, чтобы затем получить ссылки на них, которые и запишутся, то передаём объект с данными. Новые записи ввиде объектов и уже известные айдишники могут соседствовать в одном массиве.
.delete() - Финальный метод. Удаляет все выбранные записи.
.restore() - Востанавливает удалённые записи из выборки, которые ещё небыли перезаписаны.

У всех этих методов есть укороченная альтернатива, состоящая из первый трёх букв.

Самый короткий: db.qwe.get()

Подробнее о функциях в методах:
Все функции записываются анонимно как аргумент.
По результату работы функции и того, что она вернёт, будут определяться дальнейшие действия.
В параметрах таких анонимных функций указываются названия полей, значения которых будут передаваться ввиде аргументов к этой функции.
Те поля, что являюятся кроссзапросами к смежной таблице будут передаваться ввиде строки разделённых запятыми (или нет) айдишников, за исключением метода get, где поле будет преобразовано перед тем, как отдаться клиенту (в модификационных функциях тоже).
Так как функция будет прокидываться на сервер, она проходит проверку безопасности, дабы функция использовала исключительно свой скоп и не пыталась повлиять на работу базы.
Также функция теряет клиентский скоп, а это значит, что если вы хотите передать некоторое значение внутрь неё, то, как и в случае с регекспом, придётся воспользоваться конструктором (new Function).
Из соображений безопасности нельзя упоминать (кроме как в строках) объекты this, global и console.
Старайтесь, чтобы функция не возвращала undefined иначе результат может быть непредсказуем.

Подробнее о кастомных функциях из dbFuncts:
this - объект с системными данными:
	base - имя базы, с которой была выполнена функция
	project - имя проекта, с которого вызвана функция
	db - геттер, при помощи которого можно выполнять запросы к базе дефолтным синтаксисом
	user - объект с данными о юзере, который вызвал функцию (поля из таблицы в user.data)
	bury - сеттер, который добавляет функцию к массиву user.burry (или создаёт оный), все функции в котором выполняются при обрыве соединения юзера с сервером
	props - появляется только если указать эту функцию внутри .find или .filter при выборке, содержит объект с поле:значение
Параметры те, что были переданы в функцию.
Сам файл dbFuncts.js удалять нельзя.
Любые изменения в dbFuncts.js повлияют на будущие запросы без перезапуска сервера.

Для борьбы с дудосом выставлены ограничения, которые записаны и прокоментированы в @settings/limits.js
Лимиты можно менять без перезагрузки сервера, однако это не повлияет на уже идущие баны и интервалы (для их сброса понадобится перезагрузить сервер).
Удаление файла с лимитами недопустимо.

Разрешены подключения к серверу только с доменов, которые записаны в @settings/domains файле (разделять переносом). Применён будет первый подходящий домен из списка. Сабдомены также определяются отталкиваясь от найденного домена. Подключение с неизвестного домена обрывается. Если файла domains не существует, то разрешается подключение с любых доменов. Файл можно изменять и удалять/восстанавливать без необходимости перезапуска сервера.

--- Сервер

Работа с базой начинается с выбора оной и создания модели. Модель - это представление данных, тоесть кучи строк валяющихся в файлах, то как они будут проименованы, какие у них будут типы данных и кто будет иметь к ним доступ. Это как рамочка для шифрования.
При запуске сервера инициируется отдельный инстанс базы для каждой модели, хранящейся в @settings/bases, и используемой в одном из проектов. Чтобы не тратить оперативу понапрасну ненужные модели можно временно переместить в другую папку.
Модели можно изменять без необходимости перезапускать сервер. Удаление модели не повлияет на текущую сессию, можно не опасаться этого при решафлах версий моделей.
Когда новый пользователь залогинется у него появляется персональный набор данных о нём, которые тут же в базе и находятся. Затем эти данные доступны в объекте "user".
Таблицы удаляются, если они не обнаружены в модели, осторожнее.

>numb
@date={2}-{2}-{4};k{!!n}oT
@admin=this.user.data.status===1
&messages>mes([<-^]function_from_dbFuncts,level2_function,{return this.user.data.id==this.data.author||@{admin}},and_final_function)
	0-text?OP-huy
	1-date#@{date}?@!{date}
	1.9-some_shit$mate&need
	2-media=>tracks
	28-type
	54-avatar%1000
	666-author>users

Важно чтобы имена были уникальны, как и цифры, которые будут определять порядок записи и считывания полей в общей кучи данных (если позарез нужно вклинить поле, то можно использовать дробное число). Эти цифры нужны, чтобы без риска перемещать и переименовывать поля в самой модели не теряя уже существующих закреплённых за ними данных. Причём важна не сама цифра, а именно последовательность полей в порядке убывания, которыую они образуют.

Для безопасности запросов используются охранные функции (гарды), которые вызываются каждый раз, когда происходит взаимодействие с таблицой.
Для этого, после указании имени таблицы, в [] перечисляются знаки действий (> get, < set, - delete, ^ restore, + push), после чего через запятую перечисляются названия функций из dbFuncts или записанных тут же, но обрамлённых фигурными скобками.
Всё необходимое в функцию передаётся внутри контекста (this): guard - равняется true и нужен дабы идентифицировать функцию как гард, action - название действия (get, set, push, delete, restore), user - объект юзера (там токен, бури, глазюк и в data свойстве находится объект с данными) сделавшего запрос, bury - сеттер принимающий функцию которая будет выполнена после того как юзер отключится от сервера, db - интерфейс для осуществления запроса к базе, data - объект с даными из базы (есть везде, кроме push экшона), new - объект с вносимыми данными (есть только в set и push экшонах), project - название проекта, table - название таблицы, base - название базы.
При использовании this.db будут игнорироваться гарды (иначе рекурсия), а это значит, что данные будут приходить в немодифицированном состоянии, как они есть в базе. При этом react под запретом (он клиент онли ёпты).
Все действия, кроме push, требуют выборки данных, а потому триггерят get экшон и его гарды.
Как обычно, гард функции могут быть асинхронны, а те, что объявляются прямиком в модели априори асинхронны.
data и new объекты можно невозбранно изменять, что повлияет на итоговую выдачу/внесение данных.
То, что возвращает гард, приводится к булеану и на основе этого решается, выполнять ли действие или нет. Все перечисленные функции, по цепочке, должны вернуть трушное значение.
Однако если гард вернул строку, то это будет расцениваться как текст ошибки, который будет выслан как результат запроса.

Перед тем, как объявлять таблицы, можно установить переменные, которые начинаются с @, чтобы затем многократно использовать их далее в модели при помощи интерполяции @{}. Чтобы отменить интерполяцию и записать всё буквально, используйте конструкцию @!{}.

А в самом начале можно указать дефолтное возвращаемое значение после запросов (подробнее в описании метода .return()).

Знаком ? выставляется дефолтное значение для пустого поля. Причём поле так и останется пустым в базе, однако при выборке оно будет заполнено этим значением. Поэтому смена дефолтного значения повлияет на все уже имеющиеся пустые поля.

Знак % делаёт поле хранилищем файла. В значении записывается максимально-допустимый размер файла в килобайтах (1000кб=1мб). Файл должен обязательно быть закодирован в base64. Поле из базы будет автоматически содержать полный путь до файла, тобишь дописывать ничего не надо.
Для картинок форматов JPEG, PNG, WebP, TIFF, GIF и SVG есть возможность их серверной модификации индивидуально для одного этого запроса, для этого нужно передать особые ГЕТ параметры:
	?size=[width]x[height] - Изменяет размер запрашиваемой картинки. Если указать 0 в одном из значений, оно будет расчитано автоматически пропорционально. Пример: @file/8972356.jpg?size=250x0

Знаком # выставляется маска для поля. Все вносимые данные обязаны соответствовать этой маске. Сама по себе она экономит место на диске, обрезая все статичные элементы и позволяя динамично менять отображения данных с использованием новых статичных элементов.
Все статичные (повторяющиеся в каждом вносимом значении) символы записывются как есть, а длины всех динамичные данных записываются в фигурных скобках {}. Если вы хотите, чтобы это было не указанием длины, а литеральными символами, то поставьте ! сразу после открывающей скобки ({!3}, например). Чтобы указать неизвестную длину, в которую будут включены все оставшиеся символы, используйте букву n или цифру 0.

Чтобы не словить конфликтов, вся настройка вместе со служебным знаком и его значением оборачивается круглыми скобками.

= - ссылка на другую таблицу, в такие поля можно вносить целые объекты, айдишники как ссылка на другую запись и, если указать символ => , то целые массивы из объектов и/или айдишников, которые будут перенаправлены в указанную таблицу.

Чтобы переименовать таблицу, после её старого названия поставьте знак > и затем напишите новое имя. После этого запустите сервер и таблица переименуется. Затем уже можно эту конструкцию убрать, оставив лишь новое имя, но можно и оставить всё как есть.

Если перед названием таблицы стоит символ & - это таблица юзеров. Если такого символа не найдено, то по дефолту будет искаться таблица с именем user. В дальнейшем в полях такой таблицы можно использовать этот же символ, чтобы маркировать особо значимые для системы логина и безопасности поля. Маркировки таковы:
token - поле, где хранится текущий токен авторизированного юзера.
login - логин юзера для авторизации.
pass - собсно пароль.
В случае отсутствия данных маркировок будут искаться поля с аналогичным названием.
Маркировка need добавляет поле в список тех, кто будет появляться внутри коллбэков безопасности или хранимых на сервере функций. Будьте осторожны, это жрёт оперативу, дабы не дёргать базу при каждом вызове системной функции.

Пробелы можно вовсе не ставить, они всёравно будут игнорироваться. Название таблиц, полей и качеств может состоять только из букв цифр и знаков $ и _. В каждой таблице поле id идёт по дефолту и содержит в себе уникальный для каждого объекта в этой таблице набор ASCII символов, он защищён от перезаписи, что изредка может вызвать конфузы.
Можно всё правило (вместе с контрольным символом) обрамлять скобками для избежания конфликтов.