---Фреймворк
Element.anima({}[,123|{}]) - Проигрывает анимацию на элементе, меняя style свойство элемента с текущего значения до скорректированного в /1/ объекте (название:'значение'|['стартовое значение',...'значение']) и сохраняя эти значения при успешном завершении анимации. Названия CSS свойств можно записывать через "-", а не только верблюдом, как того требует animate. /2/ параметр может быть длительностью анимации в милисекундах, если передан как число или строка, или объектом с параметрами анимаций (https://developer.mozilla.org/en-US/docs/Web/API/Element/animate), по дефолту равен 400. Дополнительно объект может содержать две опции: reset:true - по окончанию анимации сбрасывает стили до первоначальных, lone:'cancel'|'finish'|'pause' - производит указанное действие с уже проигрываемыми анимациями на элементе (pause навечно зафризит анимации, осторожно). Возвращает промис, который содержит в себе методы cancel, finish, pause, play, reverse для управления анимацией, и сам объект (интерфейс) анимации под свойством face (https://developer.mozilla.org/ru/docs/Web/API/Animation). При отмене анимации переданые /1/ значения сбрасываются, а промис резольвится с false, во всех остальных случаях промис зарезольвится по окончанию анимации с интерфейсом законченной анимации. Пример, в котором цвет текста в боди сменится с текущего на красный: document.body.anima({color:'red'}) Пример, при котором цвет в боди мгновенно поменяется на розовый, а затем будет сменяться с розового на синий и с синего на красный в течении 5 секунд: document.body.anima({color:['pink','blue','red']},5000)

mlf.preload('mod|pie|garb|img',...'') - Загружает все перечисленные моды/паи/гарбы(что есть стили из пая). Возвращает промис с резольвом по завершению.

get mlf.db - Создаёт запрос к базе. Саму базу указывать не нужно, она определяется проектом. Синтаксис в серверной документации. Возвращает промис, который резольвится с результатом или режектится с ошибкой.

get mlf.ldb - Обращается к локальной базе, которая сохранена в браузере. Работать как с объектом, причём можно не париться об отсутствии каких-либо свойств, они автоматом филлятся объектами. Проблема только в том, что несуществующие поля также возвращают объект.

Array.align(...CLASS[,true]) - Выстраивает элементы в массиве так, чтобы их порядок соответствовал переданным классам-конструкторам. Классы можно указывать в массиве, тогда на эту позицию встанет элемент, подошедший под первый из указанных классов. Если в конце указать true, то все нераспределённые элементы добавятся в конец нового массива, иначе же они просто упускаются. Пример: [123,/qwe/,'qwe',false,{}].align(String,[Function,Object],RegExp,true) => ['qwe',{},/qwe/,123,false]

static fetch.easy('',{}|'') - Упрощённая версия фетча, где указать нужно только путь и данные на отправку, а возвращается промис, который затем зарезольвится с ответом от сервера или зарежектится, если код ответа был отличным от 200.

get String.noregexp - возвращает ту же строку, но все символы регекспа в ней экранированы, дабы можно было безопасно засунуть её в конструктор регекспа.

static Function.async - возвращает конструктор для асинхронной функции вместо обычной.

get mlf.subdom - возвращает прокси массив, который содержит в себе все сабдомены от текущего домена и осуществляет переход при их изменении.

set mlf.subdom(''|[]) - полностью меняет текущую цепочку сабдоменов.

mlf.samosbor('',Element|{},{}) - Осуществляет сборку шаблона /1/ и добавляет результат вконец дочек элемента /2/ (указать можно как сам элемент, так и его структуру), который body по дефолту. В /3/ можно указать кастомный core объект. Возвращает промис, который возвращает массив с элементами верхнего уровня, созданными в итоге через шаблон. Каждый элемент, созданный таким образом, имеет собственную структуру, которая хранится в свойстве .mlf

mlf.apply('',Element|{}) - Применяет /1/ строку с командами к элементу или его структуре /2/. Строка обязательно должна быть именно строкой, блоки недопустимы. Возвращает промис, который после выполнения всех команд зарезольвится со структурой элемента. Порядок аргументов не важен.

mlf.build(''[,Element|{}]) - Применяет шаблон /1/ (подробнее в описании шаблонов) к элементу или его структуре /2/ (или к body по дефолту), создавая внутри него новые элементы. Возвращает промис, который затем резольвится массивом с новыми элементами верхнего уровня. Порядок аргументов не важен.

Math.random([123,123]) - Возвращает случайное целое чесло между двумя переданными целыми числами (включая их). Если ничего не передано, то работает как обычно.

Math.operate(...*,'') - Выполняет арифмитическое действие над всеми перечисленными операндами /1/ при помощи оператора /2/ (пока он может быть только "+", "-", "*", "/", ">", "<", ">=", "<=").

mlf.ws('',*) - Через вебсокеты отсылает сообщение /2/ всем, кто подписан на ивент /1/.

get mlf.ws - Возвращает функцию выше, но её можно использовать как объект для доступа к массивам хэндлеров ивентов (ключ - название ивента). Если массив ивента содержит хотябы один хэндлер, то к вам начнут поступать сообщения, отправленные через вебсокеты на данный ивент. Удалять элементы из массива только оператором delete

Array.unite(...[]) - Изначально массив должен содержать названия ключей для будующий объектов, затем в /1/ перечисляются массивы со значениями, которые подставятся к этим ключам, в результате чего будет создан массив из объектов, количество которых равно переданным массивам в /1/. Пример ['pony','fur','gender'].unite(['Rarity','white','mare'],['Braeburn','brown','stallion']) => [{pony:'Rarity',fur:'white',gender:'mare'},{pony:'Braeburn',fur:'brown',gender:'stallion'}]

Array.add(*[,123|'']) - Вставляет /1/ на позицию /2/ (синоним для .splice(123,0,*)). Если /2/ не указан, то работает как .push() В реактивных массивах использовать строго именно эту функцию для вставки элементов.

Array.delete(123|'') - Удаляет элемент на позиции /1/ из массива (со смещением length). В реактивных массивах использовать строго именно эту функцию для удаления элементов. Фаирит делит ивент на зависимых элементах.

Array.swap(123|'',123|''[,bool]) - Меняет местами элементы на позициях /1/ и /2/. Если /3/ передан как true, то элемент на позиции /2/ не будет перемещён, а вместо этого произойдёт его удаление. В реактивных массивах использовать строго именно эту функцию для свапа элементов. Фаирит свап ивент на зависимых элементах.

mlf.login('','') - Производит попытку логина с указанными логином /1/ и паролем /2/. Возвращает промис, который при удачом контакте с сервером резольвится со статусом true/false (прошёл ли логин), а при заранее неудачном запросе мгновенно режектится с сообщением об ошибке. Не имеет смысла без подключения к базе проекта.

mlf.logout() - Производит попытку логаута. Возвращает промис, который при удачом контакте с сервером резольвится со статусом true/false (прошёл ли логаут), а при заранее неудачном запросе мгновенно режектится с сообщением об ошибке. Не имеет смысла без подключения к базе проекта.

mlf.alert(Promise|123|'') - Рождает на экране сообщение, которое будет поверх страницы (z-index: 999) и просуществует пока не выполнится (неважно с режектом или резольвом) промис /1/ или пока не истечет /1/ время в секундах (отсчёт начнётся после анимации появления, а это ещё 0.4 секунды). Возвращает сам элемент алерта, дабы можно было его модифицировать методами build и apply. Заметте, что элемент не пересоздаётся каждый раз, а лишь очищается от контента внутри и избавляется от классов.

mlf.scrut([[]],'',...fn) - Контролируемый разбор строки (когда функционала RegExp недостаточно). /1/ содержит в себе флаги (в дальнейшем массив превращается в Set для более удобного использования). /2/ разбираемая строка. /3/ очередь из функций на выполнение. Порядок аргументов не важен.
В функции /3/ первым параметром поступает объект, содержащий все параметры процесса:
	flags:Set - позволяет вносить/выносить/проверять (add/delete/has) некие уникальные значения для контроля процесса.
	str:'' - разбираемая строка.
	struct:[] - переданные функции /3/.
	res:{} - результат работы текущей итерации разбора.
	stage:123 - индекс текущей исполняемой функции из struct.
	pos:123 - индекс текущего символа из str.
	sym:'' - текущий символ, взятый из str на позиции pos.
В итоге зацикленно будет браться символ sym из строки str на позиции pos, пока pos меньше чем длина str, а затем поочерёдно запускать все функции из struct (функции принимают один аргумент, коим всегда является один и тот же объект с параметрами выше). Возвращаемое функцией значение влияет на процесс (разбор производится при помощи typeof, такчто объекты полученные из одноимённых конструкторов не годятся):
	Если функция вернула boolean или null, то это влияет на сценарий работы:
		null - процесс обрывается и возвращается null.
		false - процесс также обрывается, но возвращается всё, что накопилось.
		true - переход на следующую функцию (stage+=1), и если stage>=struct.length, то начинается следующий прогон функций (объект res добавляется к результирующему массиву, stage и res обнуляются, а flags возвращается к исходному, переданному в /2/, значению).
	Если number, то это указывает сколько нужно прибавить к pos (по дефолту это 1), однако если данное значение сделает pos>=str.length, то оно будет проигнорированно и процесс окончится.
	Если string, то это указывает имя свойства объекта res, в которое будет внесён текущий символ sym.
	Всё остальное игнорируется и происходит лишь дефолтная инкреминация pos.
	Также функции могут возвращать массив с комбинацией из различных типов значений. Их порядок неважен.
Таким образом можно вручную контролировать весь процесс разбора строки путём корректировки и проверки всех параметров процесса.
Результатом работы является массив с объектами или null. У массива есть свойство obj, которое является ссылкой на финальную версию объекта с параметрами.
	

---Модули
Хранятся в папке "mods" проекта, могут быть как еденичным файлом (*название модуля*.js) или набором файлов в одноимённой папке. Папки могут содержать ещё папки, тобишь роутиться. Автоматом из папки подсасываются файлы js.js, lib.js и lib.css, остальное дозагружать паком.
Типы загрузок для файла-сборщика "pack" (файлы можно перечислять в массиве, чтобы загрузить множество) (разрешение файлов можно не указывать, только если они не специфичные):
	js - тело функции или полноценный класс, инстанс которого затем можно использовать в коллбэке. Передаётся структура элемента, на котором был вызван модуль, как контекст, если это функция, или как аргумент в конструктор, если это класс. Если модуль является классом и нужно подождать выполнение некоего промиса после констракта и только затем продолжить цепочку действий в шаблоне, откуда он был вызван, то этот промис нужно внести в this.await
	styl - Stylus файл стилей. Стили для корневого элемента нужно писать сразу, без каких либо отступов, ибо затем автоматом вперёд допишется префикс модуля и каждой строчке в файле выдастся один таб. Глобальные стили для всего проекта пишутся в корневой директории проекта в файле global.styl и затем автоматом добавляются сюда.
	libjs - Загрузка чистого js файла как он есть.
	libcss - Аналогично.
	purestyl - Аналогично.
Пример файла pack:
libjs
	qwe/asd
	zxc
	and.js
js
	finger.ass

tip{text:'',side:'top|right|bottom|left',corner:'top|right|bottom|left',x:123,y:123} - Добавляет подсказку элементу с текстом @text@ и распологающуюся с @side@ стороны. Дополнительно можно сместить в угол @corner@ и на фиксированную величину @x@ и @y@ для точечной коррекции.
	set text('') - Меняет текст внутри подсказки.

gmap(jq[,{lat,lng}]) - Создаёт карту внутри элемента /1/ с центром в точке /2/ или в Омске.
	.coords('') - Преобразует строку в координаты и создаёт очередь.
	.mark({lat,lng}) - Создаёт маркер в указанных координатах. Если координаты небыли переданы, то встаёт в очередь.
	.focus({lat,lng}) - Перемещает центр карты к указанным координатам. Если координаты небыли переданы, то встаёт в очередь.

mosaic(jq[,'']) - Преобразует в мозаичное расположение все дочерние элементы с селектором /2/ или картинки(тэг img) внутри элемента /1/. Дочерние элементы должны иметь заданную ширину и высоту или быть элементами с автоматической их установкой при готовности (типа img). Также зависит от ширины /1/. При догрузке в /1/ элементов с указанным в /2/ селектором или img тэгов, они автоматически будут опознаваться (благодаря мутации JQ.track()) и в порядке очереди добавляться к остальным.
!!!Багнуто создание мозайки из уже заполненного контейнера, нужно создать такую же очередь загрузки, как и при асинхронном конструировании и навесить .on('load',cb), а не совершенно не годящийся для картинок .ready().

UI
	gallery(jq[,'']) - Инициирует плагин Blueimp gallery для /1/ и добавляет всех братков с селектором /2/ или с тем же самым тэгом в слайдер.
	jbox - модульные окошки jBox. Не имеет модульного класса, вызывать через "new jBox()".
	form
		icopick(jq,{}) - сторонний модуль FontIconPicker, параметры тоже от него. Превращает инпут в интерфейс для пика иконок без потери инпута.
		txteditor(jq,{}) - Trumbowyg превращает div в textarea с кнопками для форматирования текста. Обалденная штука. Валуй суётся в /1/.
		flexdatalist(jq,{}) - Добавляет выпадающий список к форме, выборка которого происходит через api.

UX
	form
		preview(jq[,jq|node|'',fn]) - Модуль ставится на input[type=file] и при выборе картинки, её base64 код устанавливается фоном или аттрибутом src в /2/. /3/ коллбэк после того, как была выбрана новая картинка, в него передаётся (/2/,/1/,base64 картинки). Сам элемент преобретает класс "haspic" при установке превьюхи (стандарт для form garb).

vk('') - Инициирует ВК апи с /1/ в качестве api id.
	.login([fn,fn]) - Открывает всплывающее окно с авторизацией в ВК. Если указан /1/, то после успешной авторизации будут запрошены данные о пользователе, которые указаны в параметрах функции, затем результат будет разобран на одноимённые аргументы и передан в эту же функцию. Список параметров для /1/ есть тут: (https://vk.com/dev/users.get). /2/ может быть каким угодно коллбэком, он не получает никаких данных и будет выполнен после успешной авторизации.

ytplayer(jq,'') - Создаёт полноэкранный проигрыватель youtube видео. В /2/ передаётся id видео.

nexus(jq[,{}]) - Контроллер для формы или одиночных инпутов-фильтров. /1/ элемент инпута или формы. /2/ - параметры, о котороых после. Проверка полей происходит установкой аттрибутов data-[valid|warn|commend], определяющие валидацию, предупреждение и похвалу соответственно. Внутри аттрибута можно указать через пробел все нужные условия, но с определённым патерном, например чтобы указать, что нельзя внести более 10 символов: max[10]=>'Десять максимум', где идёт название условия или регексп, в квадратных скобках параметр и после стрелки в литералах строка, которая выведется в сообщении. Обязательна только первая часть паттерна. Валидация и предупреждения сработают при невыполнении паттерна, похвала же напротив, при его выполнении. Также можно указать data-note, чтобы у пользователя всегда была подсказка под инпутом. Дефолтные паттерны: max[?],require и любой регексп записанный в слэшах, например /^qwe/[i] (в параметрах флаги через запятую).
	Параметры (свойства) ^2:
	event:''|123 - Название jquery ивента, при котором сработает отправка данных ('input' по дефолту). Также можно указать цифру и тогда отправка сработает при нажатии на клавишу с этим кодом.
	delay:123 - Задержка в милисекундах перед тем, как произойдёт отправка.
	button:''|jq|node - Элемент или его селектор, по нажатию на который будут отправленны данные.
	buttonEvent:'' - Переопределяет нажатие для кнопки любым другим ивентом.
	form:''|bool - Если параметр передан как true, то элемент, на котором был вызван этот модуль превратиться в форму, а все его детишки, подходящие под селектор 'input,textarea', - в поля формы. Если передать этот параметр строкой, то будет установлен новый селектор, а если в начале строки поставить знак "+", то эта строка будет как дополнение к дефолтному селектору.
	before:fn - Функция, которая выполнится перед отправкой данных на сервер. В функцию передаются ссылки на: 1) объект с собранными с полей данными; 2) свойство-объект "params"; 3) event-объект, который инициировал запуск этого коллбэка;
	params:{} - Параметры, которые будут высланы на сервер (докуметированы в разделе API).
	api:'' - Имя серверного API, куда будут отсылаться данные. По дефолту это 'api.php'. Если указать false, то данные отправляться не будут и коллбэк "after" никогда не выполнится.
	after:fn - Функция, которая выполнится после ответа от api. В функцию передаются ссылки на: 1) ответ от api ввиде объекта; 2) объект с собранными с полей данными (аттрибут "name" будет ключом и атрибут "value" значением); 3) event-объект, который инициировал запуск этого коллбэка;
	caution:bool - Включён по дефолту, добавляет блок с классом "valid" после полей формы, у которых определены условия валидации, предупреждения или похвалы.
	colors:bool - Включён по дефолту, определяет нужно ли окрашивать поля и сообщения в соответствующие цвета (зелёный, оранжевый и красный).
	notes:bool - Включён по дефолту, регулирует отображение сообщений проверки полей.
	track:bool - Включён по дефолту, будет показывать небольшое окошко в углу экрана, отображающее связь с сервером после отправки данных.
	confirm:'' - Если предано, то перед отправкой данных будет выводить на экран подтверждение действия с указанным сообщением.
	edit:bool - false по дефолту. Если передать как true, то те поля, что имеют аттрибут "value" или любое иное дефолтное значение, определяемое js свойством "defaultValue", будут перед отправкой проверяться на то, изменилось ли их дефолтное значение на что-то новое. Если нет, то для сервера сгенерируется специальное отрицательное значение, которым можно оперировать в хранимых процедурах, но которое вызовет проблемы при прямых запросах.
	clear:bool - Будут ли очищаться поля после каждой отправки данных.

hang(jq,jq|node|'',{area:jq|node|'',side:'',delevent:'',offset:123,axis:'',anim:bool}) - Превращает /1/ в нависающий сверху или сизу (в зависимости от близости границ экрана) над /2/ элемент. /3/ - устанавливает границы, в которые должен вписаться /1/ (это body по дефолту). /4/ - установка прилипания к стороне по горизонтали ('left', 'right' или 'center'). /5/ - указание события, при срабатывании которого И на /1/ И на /2/ первый удалиться. /6/ - отступ по вертикали для /1/ от /2/. /7/ - указание желательной стороны по вертикали ('top' или 'bottom', 'top' по дефолту). /8/ - нужно ли проигрывать дефолтную анимацию появления и исчезновения для /1/ (true по дефолту).

imgcolor(''|IMG,'') - Асинхроный модуль, возвращает сборный цвет картинки, полученный по указанному в /2/ алгоритму. /1/ может быть только картинкой или путём к картинке (который на месте переделывается в картинку). Алгоритм /2/ может быть следующим:
	'avg' - цвет получается тёмным
	'avgYUV' - более насыщенный цвет, но по-прежнему тёмный
	'euclideanDistance' - светлый цвет
	'kClusters' - вроде как возвращает строго преобладающий цвет

tinycolor('') - Принимает цвет (в любом формате), для дальнейшей работы с ним. Методы смотри тут: https://github.com/bgrins/TinyColor


---Роутинг
Роутинг схож с апачем - папка=страница. Страницы размещаются в папке pages. Если нужна страница, в которою будет сбрасываться юзер при отсутствии соответствующего имени, папку пожно назвать @dyn, а динамичное имя для этой страницы будет появляться в контексте шаблона как this.name. Внутри папки могут брыть другие папки, а также файлы tpl.js, css.styl и сборщик pack, однако кроме стайлуса и шаблона более ничего не поддерживается. Чтобы сделать отдельную ветку страниц в зависимости от сабдомена, нужно в корне папки pages создать папку с символом & впереди и с перечисленными сабдоменами через точку, как и в адресной строке. При этом не обязателен 100% матч, достаточно если сабдомен будет содержать лишь несколько элементов от указанных. У папок страниц можно также преписывать сабдомен(ы) впереди, тогда они бьудут в приоретете перед другими страницами при его наличии. Каждый раз, когда используются сабдомены, они обрезается на размер матча и затем могут по-прежнему быть задействованы, но в укороченном виде. Из системных страниц также есть @hood - оверлэй для всех соло страниц, @main - можно создавать только в корню всех страниц или в корню сабдоменного ответвления, является страницей, на которою попадают юзеры при вводе голого домена, @404 - страница, на которую попадают юзеры при неверно введённом адресе, может находиться только в корню всех страниц. И если в шаблоне страницы хоть как-то встречается строка "</script>", то нужно превратить её в "<\/script>", иначе всё нахер поломается. Добавление новой папки-страницы автоматически меняет древо навигации на сервере, но только на Windows и MacOS, однако даже тут могут возникать перебои, также даже если удалить страницу на сервере, она всё ещё будет в кэше у юзеров, которые на ней побывали, поэтому в любой непонятной ситуации перезагружайте сервер сначала.
Внутри tpl файла в this объекте есть следующие свойства:
	slot - Элемент, в который затем будет внесён результат шаблона.
	name - Имя страницы/пая.
	gets - (только в страницах) Объект с ГЕТ параметрами.
	core - Объект, который станет первородным биндом внутри шаблона.

mlf.page(''[,bool]) - Загружает страницу из /1/ директории и помещает её в соответствующий слот. /2/ не занесёт страницу в историю, если передать как false. Первым параметром можно указать строку '<' и тогда автоматически будет указан путь на одну директиву назад от текущей. Если первым символом идёт "/", то вперёд подставится текущий путь.

В любом месте шаблона страницы можно потребовать от сервера выполнить некое действие до передачи страницы клиенту. В дальнейшем такие запросы заменяются соответствующими свойствами объекта this, если они то подразумевают. Синтаксис должен соответствовать регулярному выражению: /^>(.+?)(?:\[(.+?)])?=([\s\S]+?);(?:\s|$)/gm; Можно использовать @dyn@ для получения соответствующей динамческой переменной. Имеющиеся команды:

appear - Замена анимации вставки страницы на свою собственную функцию. Эта функция асинхронна. this объект ссылается на слот, в который будет вставлена страница. Пример: >appear=this.anima({height:'100px'}).then(()=>this.anima({width:'100px'});
disappear - То же самое, но определяет, как эта страница будет исчезать.
type - Установка типа страницы. Дефолтно страница считается соло типом. Пример: >type=lone; Типы:
	solo - Самостоятельная страница, утанавливающаяся на весь экран или в область, ограниченную худом.
	lone - Тоже самое, но только игнорирует существование худа.
	sub - Добавляется в заранее установленный для неё слот. Саб-страницы будут по цепочке загружаться одна за другой, пока не дойдут до самостоятельной страницы.
offset - Объект с максимум четырьмя параметрами: top, right, bottom, left. Определяет насколько нужно сместить весь основной контент сайта от границы экрана. Можно использовать только в @hud странице.


---Паи
Все теги, которые не являются дефолтными HTML тэгами, являются пирожками и могут иметь свои собственные стили, шаблоны и отдельную логику работы, которые грузятся с сервера, а точнее из папки pies проекта. Роутинг по паям через дефис. Если тэг начинается с дефиса, то к нему прибавится роутинг родительского пая. В конце названия пая можно поставить собачку и написать значение, которое затем окажется в this.var шаблона. В ТПЛке, как и у страницы, контекст содержит в себе слот, имя и кору, которая наследуется от родителя. Подключение файлов также как и в модулях, только паи не могут быть еденичным файлом, а доступны лишь tpl.js и css.styl файлы. Внутри шаблона пая можно использовать символ # для создания слотов, а снаружи его же для ссылки на них (подробнее в синтаксисе шаблонов).


---Настройки
В корне папки проекта можно создать файл "settings" и вписать в него такие фичи (если впереди стоит "/", то игнорируется):
	lazy - если тру, то сервер будет отдавать лишь сообщение о загрузке, а сама страница будет загружаться в фоновом режиме, коли фэлс, что по дефолту, то сервер сразу будет отдавать предзагруженную страницу, но это слегка увеличит время ожидания ответа.
	db - название используемой базы.
	mod - если "default", то данный проект будет грузиться при переходе на основной домен. Если ни одного дефолта нет, то будет показана страница выбора проекта, которая валяется в @global под именем @crossway. Если "ignore", то на данный проект невозможно будет попасть. Если "fix", то какие поддомены не вводил бы юзер, он энивэй будет попадать сюда. Если у проекта нет своей папки в корню - он игнорируется.
	domain - если запрос будет поступать с указанного здесь домена, то в ответ всегда будет приходить именно этот проект.
	desc - описание проекта, которое используется на странице выбора проекта.
Пример:
lazy true
db test
/mod default
domain 127.0.0.1
desc Как же классно сидеть за компом в топовых шмотках.

Фавиконка должна размещаться в корне проекта под названием favicon.ico

Помимо этого есть серверные настройки, которые хранятся в папке @settings.
Файл "domains" указывает на список доменов, с которых можно подключиться к серверу. Остальные будут игнорироваться.
Пример:
localhost
127.0.0.1
192.168.1.100
2ch.hk

Файл "bases" отвечает за инициацию и настройку баз данных. Сначала пишется название базы, затем перенос строки и с вложенностью в один таб начинают прописыватся настройки:
	return - определяет вид возвращаемых значений после каждого запроса. Может быть: 'id', 'bool', 'numb', 'len', что к чему думаю понятно. Дефолт - булка.
	model - устанавливает модель базы. Подробнее в документашке к базе.
	point - объект, который указывает на таблицу и её поля, которые будут задействованы при работе с юзером.
		table - таблица, где у вас хранятся юзеры. Дефолт - "user".
		token - поле, где хранятся токены юзеров. Дефолт - "token".
		login - поле, где хранится логин юзера. Дефолт - "login".
		pass - поле, где хранится пароль юзера. Дефолт - "pass".
		props - массив с названием полей, помимо айди, логина и пароля, которые дополнительно будут вам нужны при создании правил безопасности в модели. В документашке к базе подробности.


--- И ещё кое-что
Если какое бы то нибыло обращение к серверу начинается с "@/", то собачка меняется на название текущего проекта.


---!пояснения синтаксиса!---
[,...] - необязательные параметры, и их порядок передачи, в большинстве случаев, не важен. Хотя и в обязательных параметрах порядок тоже не важен, только если там нет двух параметров с одинаковым типом данных.
/1/ - ссылка на первый параметр
Очередь - все последующие методы, которые могут встать в очередь, будут ожидать ответа от создателя очереди прежде чем выполнить свой код
Братки - siblings, тоесть все элементы в одном и том же родителе
Node - DOM элемент в ванильном js
Флаг - метод-геттер, который можно использовать в цепочке и существует он для смены состояния инстанса.
fn - означает буквальную функцию.
met - означает, что это метод, применяющийся на инстанс указанного класса.